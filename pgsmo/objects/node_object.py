# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

from abc import ABCMeta, abstractmethod
from collections import Iterator
from typing import Callable, Generic, List, Optional, Union, TypeVar


import pgsmo.utils.templating as templating
import pgsmo.utils.querying as querying


class NodeObject(metaclass=ABCMeta):
    @classmethod
    def get_nodes_for_parent(
            cls,
            conn: querying.ServerConnection,
            parent_obj: Optional['NodeObject']
    ) -> List['NodeObject']:
        """
        Renders and executes nodes.sql for the class to generate a list of NodeObjects
        :param conn: Connection to use to execute the nodes query
        :param parent_obj: The object that is the parent of all objects generated by this method
        :return: A list of NodeObjects generated with _from_node_query
        """
        template_root = cls._template_root(conn)

        # Only include a parent ID if a parent was provided
        template_vars = {}
        if parent_obj is not None:
            template_vars['parent_id'] = parent_obj._oid

        # Render and execute the template
        sql = templating.render_template(
            templating.get_template_path(template_root, 'nodes.sql', conn.version),
            **template_vars
        )
        cols, rows = conn.execute_dict(sql)

        return [cls._from_node_query(conn, **row) for row in rows]

    @classmethod
    @abstractmethod
    def _from_node_query(cls, conn: querying.ServerConnection, **kwargs) -> 'NodeObject':
        pass

    def __init__(self, conn: querying.ServerConnection, name: str):
        # Define the state of the object
        self._conn: querying.ServerConnection = conn
        self._child_collections: List[NodeCollection] = []

        # Declare node basic properties
        self._name: str = name
        self._oid: Optional[int] = None

    # PROPERTIES ###########################################################
    @property
    def name(self) -> str:
        return self._name

    @property
    def oid(self) -> Optional[int]:
        return self._oid

    # METHODS ##############################################################
    def refresh(self) -> None:
        """Refreshes and lazily loaded data"""
        self._refresh_child_collections()

    # PROTECTED HELPERS ####################################################
    TRCC = TypeVar('TRCC')

    def _register_child_collection(self, generator: Callable[[], List[TRCC]]) -> 'NodeCollection[TRCC]':
        """
        Creates a node collection for child objects and registers it with the list of child objects.
        This is very useful for ensuring that all child collections are reset when refreshing.
        :param generator: Callable for generating the list of nodes
        :return: The created node collection
        """
        collection = NodeCollection(generator)
        self._child_collections.append(collection)
        return collection

    def _refresh_child_collections(self) -> None:
        """Iterates over the registered child collections and resets them"""
        for collection in self._child_collections:
            collection.reset()

    @classmethod
    @abstractmethod
    def _template_root(cls, conn: querying.ServerConnection) -> str:
        pass


TNC = TypeVar('TNC')


class NodeCollection(Generic[TNC]):
    def __init__(self, generator: Callable[[], List[TNC]]):
        """
        Initializes a new collection of node objects.
        :param generator: A callable that returns a list of NodeObjects when called
        """
        self._generator: Callable[[], List[TNC]] = generator
        self._items_impl: Optional[List[TNC]] = None

    @property
    def _items(self) -> List[TNC]:
        # Load the items if they haven't been loaded
        if self._items_impl is None:
            self._items_impl = self._generator()

        # noinspection PyTypeChecker
        # - This should always be a list b/c _ensure_loaded will load the list if it is None
        return self._items_impl

    def __getitem__(self, index: Union[int, str]) -> TNC:
        """
        Searches for a node in the list of items by OID or name
        :param index: If an int, the object ID of the item to look up. If a str, the name of the
                      item to look up. Otherwise, TypeError will be raised.
        :raises TypeError: If index is not a str or int
        :raises NameError: If an item with the provided index does not exist
        :return: The instance that matches the provided index
        """
        # Determine how we will be looking up the item
        if isinstance(index, int):
            # Lookup is by object ID
            lookup = (lambda x: x.oid == index)
        elif isinstance(index, str):
            # Lookup is by object name
            lookup = (lambda x: x.name == index)
        else:
            raise TypeError('Index must be either a string or int')

        # Look up the desired item

        for item in self._items:
            if lookup(item):
                return item

        # If we make it to here, an item with the given index does not exist
        raise NameError('An item with the provided index does not exist')

    def __iter__(self) -> Iterator:
        return self._items.__iter__()

    def __len__(self) -> int:
        # Load the items if they haven't been loaded
        return len(self._items)

    def reset(self) -> None:
        # Empty the items so that next iteration will reload the collection
        self._items_impl = None
